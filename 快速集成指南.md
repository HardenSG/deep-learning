# å¿«é€Ÿé›†æˆæŒ‡å— - 5åˆ†é’Ÿä¸Šæ‰‹

## æ­¥éª¤1: å®‰è£…æ”¹è¿›ç‰ˆé¢„æµ‹å™¨ âœ…

æ–‡ä»¶å·²ç»åˆ›å»ºå¥½äº†ï¼š
- `src/models/improved_predictor.py`
- `src/api/improved_endpoints.py`

## æ­¥éª¤2: æ›´æ–° main.py

åœ¨ `src/api/main.py` ä¸­æ·»åŠ ï¼š

```python
# åœ¨æ–‡ä»¶é¡¶éƒ¨å¯¼å…¥
from src.models.improved_predictor import ImprovedPredictor
from src.api.improved_endpoints import (
    ImprovedPredictionResponse,
    ErrorResponse,
    ErrorCodes,
    create_error_response
)

# æ·»åŠ æ–°ç«¯ç‚¹ï¼ˆçº¦åœ¨ç¬¬258è¡Œä¹‹åï¼‰
@app.post("/api/v2/predict/comprehensive",
          response_model=ImprovedPredictionResponse,
          responses={404: {"model": ErrorResponse}, 500: {"model": ErrorResponse}})
async def predict_comprehensive(request: PredictRequest):
    """
    æ”¹è¿›ç‰ˆç»¼åˆé¢„æµ‹æ¥å£

    è¿”å›å®Œæ•´çš„é¢„æµ‹ç»“æœï¼ŒåŒ…æ‹¬ï¼š
    - ä»·æ ¼é¢„æµ‹å’Œæ¶¨è·Œå¹…
    - ä¸Šæ¶¨/ä¸‹è·Œæ¦‚ç‡ï¼ˆMonte Carloä¼°è®¡ï¼‰
    - é£é™©æŒ‡æ ‡ï¼ˆæ³¢åŠ¨ç‡ã€VaRã€å¤æ™®æ¯”ç‡ï¼‰
    - äº¤æ˜“ä¿¡å·ï¼ˆæ“ä½œå»ºè®®ã€æ­¢æŸæ­¢ç›ˆã€ä»“ä½ç®¡ç†ï¼‰
    - å…ƒæ•°æ®ï¼ˆé¢„æµ‹æ—¶é—´ã€æ¨¡å‹ç‰ˆæœ¬ã€æ•°æ®è´¨é‡ï¼‰
    """
    try:
        stock_code = request.stock_code
        model_path = Path(config.model.get("model_save_path", "data/models")) / f"{stock_code}_model.pth"
        scaler_path = Path(config.model.get("model_save_path", "data/models")) / f"{stock_code}_scaler.pkl"

        # éªŒè¯æ–‡ä»¶
        if not model_path.exists():
            raise HTTPException(
                status_code=404,
                detail=create_error_response(
                    "ModelNotFoundError",
                    f"æ¨¡å‹æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¯·å…ˆè®­ç»ƒæ¨¡å‹",
                    ErrorCodes.MODEL_NOT_FOUND,
                    {"stock_code": stock_code}
                )
            )

        if not scaler_path.exists():
            raise HTTPException(
                status_code=404,
                detail=create_error_response(
                    "ScalerNotFoundError",
                    f"Scaleræ–‡ä»¶ä¸å­˜åœ¨",
                    ErrorCodes.SCALER_NOT_FOUND,
                    {"stock_code": stock_code}
                )
            )

        # åŠ è½½æ•°æ®
        df = db.get_stock_daily(stock_code)
        if df.empty:
            raise HTTPException(
                status_code=404,
                detail=create_error_response(
                    "DataNotFoundError",
                    f"æœªæ‰¾åˆ°è‚¡ç¥¨æ•°æ®",
                    ErrorCodes.DATA_NOT_FOUND,
                    {"stock_code": stock_code}
                )
            )

        current_price = float(df.iloc[-1]["close"])

        # éªŒè¯ä»·æ ¼
        if current_price <= 0:
            raise HTTPException(
                status_code=400,
                detail=create_error_response(
                    "DataValidationError",
                    f"ä»·æ ¼æ•°æ®å¼‚å¸¸: {current_price}",
                    ErrorCodes.DATA_QUALITY_ERROR,
                    {"current_price": current_price}
                )
            )

        # å‡†å¤‡ç‰¹å¾
        stock_feature_builder = FeatureBuilder(config.features)
        stock_feature_builder.load_scaler(str(scaler_path))
        X = stock_feature_builder.prepare_prediction_data(df)

        # åŠ è½½æ¨¡å‹
        input_size = X.shape[2]
        model = LSTMModel(
            input_size=input_size,
            hidden_size=config.model.get("lstm", {}).get("hidden_size", 128),
            num_layers=config.model.get("lstm", {}).get("num_layers", 2),
            dropout=config.model.get("lstm", {}).get("dropout", 0.2)
        )

        # ä½¿ç”¨æ”¹è¿›ç‰ˆé¢„æµ‹å™¨
        predictor = ImprovedPredictor(model, config.system.get("device", "cpu"))
        predictor.load_model(str(model_path))

        # è·å–ç»¼åˆé¢„æµ‹
        result = predictor.get_comprehensive_prediction(
            X,
            current_price,
            stock_code,
            n_simulations=50  # å¯é…ç½®
        )

        return result

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"é¢„æµ‹å¤±è´¥: {e}")
        import traceback
        traceback.print_exc()

        raise HTTPException(
            status_code=500,
            detail=create_error_response(
                "PredictionError",
                str(e),
                ErrorCodes.PREDICTION_ERROR,
                {"stock_code": request.stock_code}
            )
        )
```

## æ­¥éª¤3: æµ‹è¯•æ–°API

å¯åŠ¨æœåŠ¡ï¼š
```bash
python -m uvicorn src.api.main:app --reload
```

æµ‹è¯•è¯·æ±‚ï¼š
```bash
curl -X POST "http://localhost:8000/api/v2/predict/comprehensive" \
  -H "Content-Type: application/json" \
  -d '{"stock_code": "600519"}'
```

æˆ–è€…è®¿é—® http://localhost:8000/docs æŸ¥çœ‹äº¤äº’å¼æ–‡æ¡£

## æ­¥éª¤4: Pythonå®¢æˆ·ç«¯ç¤ºä¾‹

```python
import requests

def get_prediction(stock_code):
    response = requests.post(
        "http://localhost:8000/api/v2/predict/comprehensive",
        json={"stock_code": stock_code}
    )

    if response.status_code == 200:
        result = response.json()

        print(f"è‚¡ç¥¨ä»£ç : {result['metadata']['stock_code']}")
        print(f"é¢„æµ‹æ—¶é—´: {result['metadata']['prediction_time']}")
        print(f"æ•°æ®è´¨é‡: {result['metadata']['data_quality']['level']}")
        print(f"\nä»·æ ¼:")
        print(f"  å½“å‰: {result['price']['current']:.2f}")
        print(f"  é¢„æµ‹: {result['price']['predicted']:.2f}")
        print(f"  å˜åŒ–: {result['price']['change_pct']:+.2f}%")
        print(f"\næ¦‚ç‡:")
        print(f"  ä¸Šæ¶¨: {result['probability']['up']:.1f}%")
        print(f"  ä¸‹è·Œ: {result['probability']['down']:.1f}%")
        print(f"\näº¤æ˜“å»ºè®®:")
        print(f"  æ“ä½œ: {result['trading_signals']['action']}")
        print(f"  åŸå› : {result['trading_signals']['reason']}")
        print(f"  ä»“ä½: {result['trading_signals']['position']['suggested_pct']}%")
        print(f"  æ­¢æŸ: {result['trading_signals']['stop_loss']['price']:.2f}")
        print(f"  æ­¢ç›ˆ: {result['trading_signals']['take_profit']['price']:.2f}")
        print(f"  é£é™©: {result['trading_signals']['risk_assessment']['overall_risk']}")

        return result
    else:
        error = response.json()
        print(f"é”™è¯¯: {error['error']}")
        print(f"ä¿¡æ¯: {error['message']}")
        print(f"ä»£ç : {error['error_code']}")
        return None

# ä½¿ç”¨
result = get_prediction("600519")
```

## å®Œæˆï¼ğŸ‰

ç°åœ¨ä½ çš„APIå·²ç»å…·å¤‡ï¼š
- âœ… å®Œæ•´çš„é¢„æµ‹ç»“æœ
- âœ… å‡†ç¡®çš„æ¦‚ç‡ä¼°è®¡
- âœ… å®Œå–„çš„é£é™©æŒ‡æ ‡
- âœ… å®ç”¨çš„äº¤æ˜“ä¿¡å·
- âœ… æ ‡å‡†çš„é”™è¯¯å¤„ç†
- âœ… è¯¦ç»†çš„å…ƒæ•°æ®

## APIç«¯ç‚¹å¯¹æ¯”

| ç«¯ç‚¹ | ç”¨é€” | æ¨è |
|------|------|------|
| `/api/predict` | ç®€å•é¢„æµ‹ï¼ˆæ—§ï¼‰ | âš ï¸ ä¿ç•™å…¼å®¹ |
| `/api/predict/enhanced` | å¢å¼ºé¢„æµ‹ï¼ˆæ—§ï¼‰ | âš ï¸ ä¿ç•™å…¼å®¹ |
| `/api/v2/predict/comprehensive` | ç»¼åˆé¢„æµ‹ï¼ˆæ–°ï¼‰ | â­ æ¨èä½¿ç”¨ |

## æ€§èƒ½ä¼˜åŒ–å»ºè®®

å¦‚æœéœ€è¦æ›´å¿«çš„å“åº”é€Ÿåº¦ï¼š

```python
# åœ¨ predict_comprehensive ä¸­è°ƒæ•´
result = predictor.get_comprehensive_prediction(
    X, current_price, stock_code,
    n_simulations=20  # ä»50é™åˆ°20ï¼Œé€Ÿåº¦å¿«ä¸€å€
)
```

## æ·»åŠ ç¼“å­˜ï¼ˆå¯é€‰ï¼‰

```python
from functools import lru_cache
from datetime import datetime, timedelta

# ç®€å•çš„å†…å­˜ç¼“å­˜
prediction_cache = {}
CACHE_TTL = 60  # 60ç§’

@app.post("/api/v2/predict/comprehensive")
async def predict_comprehensive(request: PredictRequest):
    # æ£€æŸ¥ç¼“å­˜
    cache_key = f"{request.stock_code}_{datetime.now().strftime('%Y%m%d%H%M')}"
    if cache_key in prediction_cache:
        logger.info(f"ä»ç¼“å­˜è¿”å›: {cache_key}")
        return prediction_cache[cache_key]

    # ... åŸæœ‰ä»£ç  ...

    # ä¿å­˜åˆ°ç¼“å­˜
    prediction_cache[cache_key] = result
    return result
```

---

**é›†æˆæ—¶é—´**: < 5åˆ†é’Ÿ
**éš¾åº¦**: â­â­â˜†â˜†â˜† (ç®€å•)
**æ•ˆæœ**: â­â­â­â­â­ (æ˜¾è‘—)
